// Code generated by protoc-gen-go. DO NOT EDIT.
// source: platformer.proto

/*
Package platformer is a generated protocol buffer package.

It is generated from these files:
	platformer.proto

It has these top-level messages:
	UserData
	Command
	Position
	ClientUpdate
	ServerUpdate
*/
package platformer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Actions being executed (To be animated, Clients change status to dead/alive, etc.)
type Command_CommandType int32

const (
	Command_DIED         Command_CommandType = 0
	Command_QUIT         Command_CommandType = 1
	Command_JOINED       Command_CommandType = 2
	Command_TAUNT        Command_CommandType = 3
	Command_ATTACK_LEFT  Command_CommandType = 4
	Command_ATTACK_RIGHT Command_CommandType = 5
	Command_JUMP         Command_CommandType = 6
)

var Command_CommandType_name = map[int32]string{
	0: "DIED",
	1: "QUIT",
	2: "JOINED",
	3: "TAUNT",
	4: "ATTACK_LEFT",
	5: "ATTACK_RIGHT",
	6: "JUMP",
}
var Command_CommandType_value = map[string]int32{
	"DIED":         0,
	"QUIT":         1,
	"JOINED":       2,
	"TAUNT":        3,
	"ATTACK_LEFT":  4,
	"ATTACK_RIGHT": 5,
	"JUMP":         6,
}

func (x Command_CommandType) String() string {
	return proto.EnumName(Command_CommandType_name, int32(x))
}
func (Command_CommandType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type UserData struct {
	UserIdentifier int32  `protobuf:"varint,1,opt,name=user_identifier,json=userIdentifier" json:"user_identifier,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *UserData) Reset()                    { *m = UserData{} }
func (m *UserData) String() string            { return proto.CompactTextString(m) }
func (*UserData) ProtoMessage()               {}
func (*UserData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UserData) GetUserIdentifier() int32 {
	if m != nil {
		return m.UserIdentifier
	}
	return 0
}

func (m *UserData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Command struct {
	Command Command_CommandType `protobuf:"varint,1,opt,name=command,enum=platformer.Command_CommandType" json:"command,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Command) GetCommand() Command_CommandType {
	if m != nil {
		return m.Command
	}
	return Command_DIED
}

type Position struct {
	// Payload
	X    float32 `protobuf:"fixed32,3,opt,name=x" json:"x,omitempty"`
	Y    float32 `protobuf:"fixed32,4,opt,name=y" json:"y,omitempty"`
	VelX float32 `protobuf:"fixed32,5,opt,name=vel_x,json=velX" json:"vel_x,omitempty"`
	VelY float32 `protobuf:"fixed32,6,opt,name=vel_y,json=velY" json:"vel_y,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Position) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Position) GetVelX() float32 {
	if m != nil {
		return m.VelX
	}
	return 0
}

func (m *Position) GetVelY() float32 {
	if m != nil {
		return m.VelY
	}
	return 0
}

type ClientUpdate struct {
	// Types that are valid to be assigned to UpdatePayload:
	//	*ClientUpdate_C
	//	*ClientUpdate_P
	UpdatePayload isClientUpdate_UpdatePayload `protobuf_oneof:"updatePayload"`
}

func (m *ClientUpdate) Reset()                    { *m = ClientUpdate{} }
func (m *ClientUpdate) String() string            { return proto.CompactTextString(m) }
func (*ClientUpdate) ProtoMessage()               {}
func (*ClientUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isClientUpdate_UpdatePayload interface {
	isClientUpdate_UpdatePayload()
}

type ClientUpdate_C struct {
	C *Command `protobuf:"bytes,1,opt,name=c,oneof"`
}
type ClientUpdate_P struct {
	P *Position `protobuf:"bytes,2,opt,name=p,oneof"`
}

func (*ClientUpdate_C) isClientUpdate_UpdatePayload() {}
func (*ClientUpdate_P) isClientUpdate_UpdatePayload() {}

func (m *ClientUpdate) GetUpdatePayload() isClientUpdate_UpdatePayload {
	if m != nil {
		return m.UpdatePayload
	}
	return nil
}

func (m *ClientUpdate) GetC() *Command {
	if x, ok := m.GetUpdatePayload().(*ClientUpdate_C); ok {
		return x.C
	}
	return nil
}

func (m *ClientUpdate) GetP() *Position {
	if x, ok := m.GetUpdatePayload().(*ClientUpdate_P); ok {
		return x.P
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientUpdate_OneofMarshaler, _ClientUpdate_OneofUnmarshaler, _ClientUpdate_OneofSizer, []interface{}{
		(*ClientUpdate_C)(nil),
		(*ClientUpdate_P)(nil),
	}
}

func _ClientUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientUpdate)
	// updatePayload
	switch x := m.UpdatePayload.(type) {
	case *ClientUpdate_C:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.C); err != nil {
			return err
		}
	case *ClientUpdate_P:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.P); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientUpdate.UpdatePayload has unexpected type %T", x)
	}
	return nil
}

func _ClientUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientUpdate)
	switch tag {
	case 1: // updatePayload.c
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Command)
		err := b.DecodeMessage(msg)
		m.UpdatePayload = &ClientUpdate_C{msg}
		return true, err
	case 2: // updatePayload.p
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Position)
		err := b.DecodeMessage(msg)
		m.UpdatePayload = &ClientUpdate_P{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientUpdate)
	// updatePayload
	switch x := m.UpdatePayload.(type) {
	case *ClientUpdate_C:
		s := proto.Size(x.C)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientUpdate_P:
		s := proto.Size(x.P)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServerUpdate struct {
	UserIdentifier int32 `protobuf:"varint,1,opt,name=user_identifier,json=userIdentifier" json:"user_identifier,omitempty"`
	// Types that are valid to be assigned to UpdatePayload:
	//	*ServerUpdate_C
	//	*ServerUpdate_P
	UpdatePayload isServerUpdate_UpdatePayload `protobuf_oneof:"updatePayload"`
}

func (m *ServerUpdate) Reset()                    { *m = ServerUpdate{} }
func (m *ServerUpdate) String() string            { return proto.CompactTextString(m) }
func (*ServerUpdate) ProtoMessage()               {}
func (*ServerUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isServerUpdate_UpdatePayload interface {
	isServerUpdate_UpdatePayload()
}

type ServerUpdate_C struct {
	C *Command `protobuf:"bytes,2,opt,name=c,oneof"`
}
type ServerUpdate_P struct {
	P *Position `protobuf:"bytes,3,opt,name=p,oneof"`
}

func (*ServerUpdate_C) isServerUpdate_UpdatePayload() {}
func (*ServerUpdate_P) isServerUpdate_UpdatePayload() {}

func (m *ServerUpdate) GetUpdatePayload() isServerUpdate_UpdatePayload {
	if m != nil {
		return m.UpdatePayload
	}
	return nil
}

func (m *ServerUpdate) GetUserIdentifier() int32 {
	if m != nil {
		return m.UserIdentifier
	}
	return 0
}

func (m *ServerUpdate) GetC() *Command {
	if x, ok := m.GetUpdatePayload().(*ServerUpdate_C); ok {
		return x.C
	}
	return nil
}

func (m *ServerUpdate) GetP() *Position {
	if x, ok := m.GetUpdatePayload().(*ServerUpdate_P); ok {
		return x.P
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServerUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServerUpdate_OneofMarshaler, _ServerUpdate_OneofUnmarshaler, _ServerUpdate_OneofSizer, []interface{}{
		(*ServerUpdate_C)(nil),
		(*ServerUpdate_P)(nil),
	}
}

func _ServerUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServerUpdate)
	// updatePayload
	switch x := m.UpdatePayload.(type) {
	case *ServerUpdate_C:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.C); err != nil {
			return err
		}
	case *ServerUpdate_P:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.P); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServerUpdate.UpdatePayload has unexpected type %T", x)
	}
	return nil
}

func _ServerUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServerUpdate)
	switch tag {
	case 2: // updatePayload.c
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Command)
		err := b.DecodeMessage(msg)
		m.UpdatePayload = &ServerUpdate_C{msg}
		return true, err
	case 3: // updatePayload.p
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Position)
		err := b.DecodeMessage(msg)
		m.UpdatePayload = &ServerUpdate_P{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServerUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServerUpdate)
	// updatePayload
	switch x := m.UpdatePayload.(type) {
	case *ServerUpdate_C:
		s := proto.Size(x.C)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerUpdate_P:
		s := proto.Size(x.P)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*UserData)(nil), "platformer.UserData")
	proto.RegisterType((*Command)(nil), "platformer.Command")
	proto.RegisterType((*Position)(nil), "platformer.Position")
	proto.RegisterType((*ClientUpdate)(nil), "platformer.ClientUpdate")
	proto.RegisterType((*ServerUpdate)(nil), "platformer.ServerUpdate")
	proto.RegisterEnum("platformer.Command_CommandType", Command_CommandType_name, Command_CommandType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GameServer service

type GameServerClient interface {
	// Users stream in their position & command updates, and recieve the updates from other users
	Connect(ctx context.Context, opts ...grpc.CallOption) (GameServer_ConnectClient, error)
	// Get information about a user (Name, avatar, etc.)
	// Only the user_identifier need be filled in
	UserInformation(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*UserData, error)
}

type gameServerClient struct {
	cc *grpc.ClientConn
}

func NewGameServerClient(cc *grpc.ClientConn) GameServerClient {
	return &gameServerClient{cc}
}

func (c *gameServerClient) Connect(ctx context.Context, opts ...grpc.CallOption) (GameServer_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GameServer_serviceDesc.Streams[0], c.cc, "/platformer.GameServer/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &gameServerConnectClient{stream}
	return x, nil
}

type GameServer_ConnectClient interface {
	Send(*ClientUpdate) error
	Recv() (*ServerUpdate, error)
	grpc.ClientStream
}

type gameServerConnectClient struct {
	grpc.ClientStream
}

func (x *gameServerConnectClient) Send(m *ClientUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gameServerConnectClient) Recv() (*ServerUpdate, error) {
	m := new(ServerUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gameServerClient) UserInformation(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*UserData, error) {
	out := new(UserData)
	err := grpc.Invoke(ctx, "/platformer.GameServer/UserInformation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GameServer service

type GameServerServer interface {
	// Users stream in their position & command updates, and recieve the updates from other users
	Connect(GameServer_ConnectServer) error
	// Get information about a user (Name, avatar, etc.)
	// Only the user_identifier need be filled in
	UserInformation(context.Context, *UserData) (*UserData, error)
}

func RegisterGameServerServer(s *grpc.Server, srv GameServerServer) {
	s.RegisterService(&_GameServer_serviceDesc, srv)
}

func _GameServer_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GameServerServer).Connect(&gameServerConnectServer{stream})
}

type GameServer_ConnectServer interface {
	Send(*ServerUpdate) error
	Recv() (*ClientUpdate, error)
	grpc.ServerStream
}

type gameServerConnectServer struct {
	grpc.ServerStream
}

func (x *gameServerConnectServer) Send(m *ServerUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gameServerConnectServer) Recv() (*ClientUpdate, error) {
	m := new(ClientUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GameServer_UserInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServerServer).UserInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/platformer.GameServer/UserInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServerServer).UserInformation(ctx, req.(*UserData))
	}
	return interceptor(ctx, in, info, handler)
}

var _GameServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "platformer.GameServer",
	HandlerType: (*GameServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserInformation",
			Handler:    _GameServer_UserInformation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _GameServer_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "platformer.proto",
}

func init() { proto.RegisterFile("platformer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0xb3, 0x89, 0x9d, 0xa6, 0x93, 0xd0, 0xac, 0xa6, 0x1c, 0xac, 0x5e, 0x88, 0x0c, 0x12,
	0x39, 0x55, 0x28, 0x9c, 0x38, 0xa1, 0x90, 0x84, 0xd4, 0x05, 0x4a, 0x30, 0xb6, 0x04, 0xa7, 0x68,
	0x49, 0xa6, 0x92, 0x91, 0xbd, 0xb6, 0x36, 0xdb, 0x28, 0x7e, 0x0d, 0x78, 0x0c, 0x5e, 0x12, 0xed,
	0x26, 0x2e, 0x8e, 0xd4, 0x43, 0x39, 0x79, 0xf6, 0xf3, 0xaf, 0xd9, 0x7f, 0x76, 0x7e, 0xe0, 0x45,
	0x2a, 0xf4, 0x6d, 0xae, 0x32, 0x52, 0x97, 0x85, 0xca, 0x75, 0x8e, 0xf0, 0x8f, 0xf8, 0x73, 0xe8,
	0xc4, 0x1b, 0x52, 0x53, 0xa1, 0x05, 0xbe, 0x84, 0xfe, 0xdd, 0x86, 0xd4, 0x32, 0x59, 0x93, 0xd4,
	0xc9, 0x6d, 0x42, 0xca, 0x63, 0x03, 0x36, 0x74, 0xc3, 0x33, 0x83, 0x83, 0x7b, 0x8a, 0x08, 0x8e,
	0x14, 0x19, 0x79, 0xcd, 0x01, 0x1b, 0x9e, 0x86, 0xb6, 0xf6, 0xff, 0x30, 0x38, 0x99, 0xe4, 0x59,
	0x26, 0xe4, 0x1a, 0xdf, 0xc0, 0xc9, 0x6a, 0x5f, 0xda, 0x06, 0x67, 0xa3, 0x67, 0x97, 0x35, 0x13,
	0x07, 0x55, 0xf5, 0x8d, 0xca, 0x82, 0xc2, 0x4a, 0xef, 0x13, 0x74, 0x6b, 0x1c, 0x3b, 0xe0, 0x4c,
	0x83, 0xd9, 0x94, 0x37, 0x4c, 0xf5, 0x25, 0x0e, 0x22, 0xce, 0x10, 0xa0, 0x7d, 0xfd, 0x39, 0xb8,
	0x99, 0x4d, 0x79, 0x13, 0x4f, 0xc1, 0x8d, 0xc6, 0xf1, 0x4d, 0xc4, 0x5b, 0xd8, 0x87, 0xee, 0x38,
	0x8a, 0xc6, 0x93, 0x0f, 0xcb, 0x8f, 0xb3, 0xf7, 0x11, 0x77, 0x90, 0x43, 0xef, 0x00, 0xc2, 0x60,
	0x7e, 0x15, 0x71, 0xd7, 0xf4, 0xb8, 0x8e, 0x3f, 0x2d, 0x78, 0xdb, 0x5f, 0x40, 0x67, 0x91, 0x6f,
	0x12, 0x9d, 0xe4, 0x12, 0x7b, 0xc0, 0x76, 0x5e, 0x6b, 0xc0, 0x86, 0xcd, 0x90, 0xed, 0xcc, 0xa9,
	0xf4, 0x9c, 0xfd, 0xa9, 0xc4, 0x73, 0x70, 0xb7, 0x94, 0x2e, 0x77, 0x9e, 0x6b, 0x89, 0xb3, 0xa5,
	0xf4, 0x5b, 0x05, 0x4b, 0xaf, 0x7d, 0x0f, 0xbf, 0xfb, 0x3f, 0xa1, 0x37, 0x49, 0x13, 0x92, 0x3a,
	0x2e, 0xd6, 0x42, 0x13, 0x3e, 0x07, 0xb6, 0xb2, 0xd3, 0x77, 0x47, 0xe7, 0x0f, 0x4c, 0x7f, 0xd5,
	0x08, 0xd9, 0x0a, 0x5f, 0x00, 0x2b, 0xec, 0x2b, 0x76, 0x47, 0x4f, 0xeb, 0xa2, 0xca, 0x9b, 0x51,
	0x15, 0xef, 0xfa, 0xf0, 0xe4, 0xce, 0x36, 0x5d, 0x88, 0x32, 0xcd, 0xc5, 0xda, 0xff, 0xcd, 0xa0,
	0xf7, 0x95, 0xd4, 0x96, 0xd4, 0xe1, 0xb2, 0x47, 0x6f, 0xce, 0xba, 0x6a, 0x3e, 0xc6, 0x55, 0xeb,
	0x7f, 0x5d, 0x8d, 0x7e, 0x31, 0x80, 0xb9, 0xc8, 0x68, 0xef, 0x0c, 0x27, 0x26, 0x0f, 0x52, 0xd2,
	0x4a, 0xa3, 0x77, 0x74, 0x55, 0xed, 0x95, 0x2e, 0x8e, 0xfe, 0xd4, 0x47, 0xf2, 0x1b, 0x43, 0xf6,
	0x8a, 0xe1, 0x5b, 0xe8, 0x9b, 0x78, 0x06, 0xd2, 0x48, 0x84, 0x5d, 0xd7, 0x91, 0xa5, 0x2a, 0xbb,
	0x17, 0x0f, 0x52, 0xbf, 0xf1, 0xa3, 0x6d, 0x23, 0xff, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x5f, 0x28, 0x25, 0x25, 0x06, 0x03, 0x00, 0x00,
}
