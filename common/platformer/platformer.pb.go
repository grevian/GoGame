// Code generated by protoc-gen-go. DO NOT EDIT.
// source: platformer.proto

/*
Package platformer is a generated protocol buffer package.

It is generated from these files:
	platformer.proto

It has these top-level messages:
	UserData
	Command
	Position
*/
package platformer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Actions being executed (To be animated, Clients change status to dead/alive, etc.)
type Command_CommandType int32

const (
	Command_DIED         Command_CommandType = 0
	Command_QUIT         Command_CommandType = 1
	Command_JOINED       Command_CommandType = 2
	Command_TAUNT        Command_CommandType = 3
	Command_ATTACK_LEFT  Command_CommandType = 4
	Command_ATTACK_RIGHT Command_CommandType = 5
)

var Command_CommandType_name = map[int32]string{
	0: "DIED",
	1: "QUIT",
	2: "JOINED",
	3: "TAUNT",
	4: "ATTACK_LEFT",
	5: "ATTACK_RIGHT",
}
var Command_CommandType_value = map[string]int32{
	"DIED":         0,
	"QUIT":         1,
	"JOINED":       2,
	"TAUNT":        3,
	"ATTACK_LEFT":  4,
	"ATTACK_RIGHT": 5,
}

func (x Command_CommandType) String() string {
	return proto.EnumName(Command_CommandType_name, int32(x))
}
func (Command_CommandType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type UserData struct {
	UserIdentifier int32  `protobuf:"varint,1,opt,name=user_identifier,json=userIdentifier" json:"user_identifier,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *UserData) Reset()                    { *m = UserData{} }
func (m *UserData) String() string            { return proto.CompactTextString(m) }
func (*UserData) ProtoMessage()               {}
func (*UserData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UserData) GetUserIdentifier() int32 {
	if m != nil {
		return m.UserIdentifier
	}
	return 0
}

func (m *UserData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Command struct {
	// Synchronization information
	Clock int64 `protobuf:"varint,1,opt,name=clock" json:"clock,omitempty"`
	// User information
	UserIdentifier int32               `protobuf:"varint,2,opt,name=user_identifier,json=userIdentifier" json:"user_identifier,omitempty"`
	Command        Command_CommandType `protobuf:"varint,3,opt,name=command,enum=platformer.Command_CommandType" json:"command,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Command) GetClock() int64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *Command) GetUserIdentifier() int32 {
	if m != nil {
		return m.UserIdentifier
	}
	return 0
}

func (m *Command) GetCommand() Command_CommandType {
	if m != nil {
		return m.Command
	}
	return Command_DIED
}

type Position struct {
	// Server synchronization information
	Clock int64 `protobuf:"varint,1,opt,name=clock" json:"clock,omitempty"`
	// User identification data
	UserIdentifier int32 `protobuf:"varint,2,opt,name=user_identifier,json=userIdentifier" json:"user_identifier,omitempty"`
	// Payload
	X    float32 `protobuf:"fixed32,3,opt,name=x" json:"x,omitempty"`
	Y    float32 `protobuf:"fixed32,4,opt,name=y" json:"y,omitempty"`
	VelX float32 `protobuf:"fixed32,5,opt,name=vel_x,json=velX" json:"vel_x,omitempty"`
	VelY float32 `protobuf:"fixed32,6,opt,name=vel_y,json=velY" json:"vel_y,omitempty"`
}

func (m *Position) Reset()                    { *m = Position{} }
func (m *Position) String() string            { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()               {}
func (*Position) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Position) GetClock() int64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *Position) GetUserIdentifier() int32 {
	if m != nil {
		return m.UserIdentifier
	}
	return 0
}

func (m *Position) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Position) GetVelX() float32 {
	if m != nil {
		return m.VelX
	}
	return 0
}

func (m *Position) GetVelY() float32 {
	if m != nil {
		return m.VelY
	}
	return 0
}

func init() {
	proto.RegisterType((*UserData)(nil), "platformer.UserData")
	proto.RegisterType((*Command)(nil), "platformer.Command")
	proto.RegisterType((*Position)(nil), "platformer.Position")
	proto.RegisterEnum("platformer.Command_CommandType", Command_CommandType_name, Command_CommandType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GameServer service

type GameServerClient interface {
	// Users stream in their position updates, and recieve the updates from other users
	PositionUpdates(ctx context.Context, opts ...grpc.CallOption) (GameServer_PositionUpdatesClient, error)
	CommandUpdates(ctx context.Context, opts ...grpc.CallOption) (GameServer_CommandUpdatesClient, error)
	// Get information about a user (Name, avatar, etc.)
	// Only the user_identifier need be filled in
	UserInformation(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*UserData, error)
}

type gameServerClient struct {
	cc *grpc.ClientConn
}

func NewGameServerClient(cc *grpc.ClientConn) GameServerClient {
	return &gameServerClient{cc}
}

func (c *gameServerClient) PositionUpdates(ctx context.Context, opts ...grpc.CallOption) (GameServer_PositionUpdatesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GameServer_serviceDesc.Streams[0], c.cc, "/platformer.GameServer/PositionUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &gameServerPositionUpdatesClient{stream}
	return x, nil
}

type GameServer_PositionUpdatesClient interface {
	Send(*Position) error
	Recv() (*Position, error)
	grpc.ClientStream
}

type gameServerPositionUpdatesClient struct {
	grpc.ClientStream
}

func (x *gameServerPositionUpdatesClient) Send(m *Position) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gameServerPositionUpdatesClient) Recv() (*Position, error) {
	m := new(Position)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gameServerClient) CommandUpdates(ctx context.Context, opts ...grpc.CallOption) (GameServer_CommandUpdatesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GameServer_serviceDesc.Streams[1], c.cc, "/platformer.GameServer/CommandUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &gameServerCommandUpdatesClient{stream}
	return x, nil
}

type GameServer_CommandUpdatesClient interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type gameServerCommandUpdatesClient struct {
	grpc.ClientStream
}

func (x *gameServerCommandUpdatesClient) Send(m *Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gameServerCommandUpdatesClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gameServerClient) UserInformation(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*UserData, error) {
	out := new(UserData)
	err := grpc.Invoke(ctx, "/platformer.GameServer/UserInformation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GameServer service

type GameServerServer interface {
	// Users stream in their position updates, and recieve the updates from other users
	PositionUpdates(GameServer_PositionUpdatesServer) error
	CommandUpdates(GameServer_CommandUpdatesServer) error
	// Get information about a user (Name, avatar, etc.)
	// Only the user_identifier need be filled in
	UserInformation(context.Context, *UserData) (*UserData, error)
}

func RegisterGameServerServer(s *grpc.Server, srv GameServerServer) {
	s.RegisterService(&_GameServer_serviceDesc, srv)
}

func _GameServer_PositionUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GameServerServer).PositionUpdates(&gameServerPositionUpdatesServer{stream})
}

type GameServer_PositionUpdatesServer interface {
	Send(*Position) error
	Recv() (*Position, error)
	grpc.ServerStream
}

type gameServerPositionUpdatesServer struct {
	grpc.ServerStream
}

func (x *gameServerPositionUpdatesServer) Send(m *Position) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gameServerPositionUpdatesServer) Recv() (*Position, error) {
	m := new(Position)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GameServer_CommandUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GameServerServer).CommandUpdates(&gameServerCommandUpdatesServer{stream})
}

type GameServer_CommandUpdatesServer interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ServerStream
}

type gameServerCommandUpdatesServer struct {
	grpc.ServerStream
}

func (x *gameServerCommandUpdatesServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gameServerCommandUpdatesServer) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GameServer_UserInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServerServer).UserInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/platformer.GameServer/UserInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServerServer).UserInformation(ctx, req.(*UserData))
	}
	return interceptor(ctx, in, info, handler)
}

var _GameServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "platformer.GameServer",
	HandlerType: (*GameServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserInformation",
			Handler:    _GameServer_UserInformation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PositionUpdates",
			Handler:       _GameServer_PositionUpdates_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CommandUpdates",
			Handler:       _GameServer_CommandUpdates_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "platformer.proto",
}

func init() { proto.RegisterFile("platformer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 378 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xcd, 0x6e, 0xda, 0x40,
	0x10, 0xc7, 0x59, 0x63, 0xf3, 0x31, 0x20, 0xbc, 0x5a, 0x38, 0x58, 0x5c, 0x8a, 0x7c, 0xa9, 0x4f,
	0xa8, 0xa2, 0xa7, 0x9e, 0x5a, 0x84, 0x29, 0x75, 0x5b, 0x91, 0xc4, 0x59, 0x4b, 0x89, 0x72, 0x40,
	0x1b, 0x58, 0x24, 0x2b, 0xfe, 0xd2, 0xda, 0x41, 0xf8, 0x29, 0xf2, 0x72, 0x79, 0x80, 0x3c, 0x4a,
	0xe4, 0x2f, 0xe2, 0x83, 0x6f, 0x39, 0xed, 0xcc, 0x6f, 0x66, 0xff, 0xbb, 0xf3, 0xd7, 0x00, 0x8e,
	0x3c, 0x96, 0x1c, 0x43, 0xe1, 0x73, 0x31, 0x8f, 0x44, 0x98, 0x84, 0x04, 0x3e, 0x88, 0xbe, 0x81,
	0x9e, 0x13, 0x73, 0x61, 0xb2, 0x84, 0x91, 0xaf, 0xa0, 0x3e, 0xc7, 0x5c, 0xec, 0xdc, 0x03, 0x0f,
	0x12, 0xf7, 0xe8, 0x72, 0xa1, 0xa1, 0x19, 0x32, 0x14, 0x7b, 0x94, 0x61, 0xeb, 0x42, 0x09, 0x01,
	0x39, 0x60, 0x3e, 0xd7, 0xa4, 0x19, 0x32, 0xfa, 0x76, 0x1e, 0xeb, 0x6f, 0x08, 0xba, 0xab, 0xd0,
	0xf7, 0x59, 0x70, 0x20, 0x13, 0x50, 0xf6, 0x5e, 0xb8, 0x7f, 0xca, 0xaf, 0xb7, 0xed, 0x22, 0x69,
	0x92, 0x97, 0x1a, 0xe5, 0x7f, 0x40, 0x77, 0x5f, 0x28, 0x69, 0xed, 0x19, 0x32, 0x46, 0x8b, 0x2f,
	0xf3, 0xda, 0x0c, 0xe5, 0x23, 0xd5, 0x49, 0xd3, 0x88, 0xdb, 0x55, 0xbf, 0xfe, 0x00, 0x83, 0x1a,
	0x27, 0x3d, 0x90, 0x4d, 0x6b, 0x6d, 0xe2, 0x56, 0x16, 0xdd, 0x38, 0x16, 0xc5, 0x88, 0x00, 0x74,
	0xfe, 0x5e, 0x59, 0xdb, 0xb5, 0x89, 0x25, 0xd2, 0x07, 0x85, 0x2e, 0x9d, 0x2d, 0xc5, 0x6d, 0xa2,
	0xc2, 0x60, 0x49, 0xe9, 0x72, 0xf5, 0x6f, 0xf7, 0x7f, 0xfd, 0x9b, 0x62, 0x99, 0x60, 0x18, 0x96,
	0xc0, 0xb6, 0x36, 0x7f, 0x28, 0x56, 0xf4, 0x17, 0x04, 0xbd, 0xeb, 0x30, 0x76, 0x13, 0x37, 0x0c,
	0x3e, 0x3b, 0xe3, 0x10, 0xd0, 0x39, 0x9f, 0x4e, 0xb2, 0xd1, 0x39, 0xcb, 0x52, 0x4d, 0x2e, 0xb2,
	0x94, 0x8c, 0x41, 0x39, 0x71, 0x6f, 0x77, 0xd6, 0x94, 0x9c, 0xc8, 0x27, 0xee, 0xdd, 0x55, 0x30,
	0xd5, 0x3a, 0x17, 0x78, 0xbf, 0x78, 0x45, 0x00, 0x1b, 0xe6, 0xf3, 0x5b, 0x2e, 0x4e, 0x5c, 0x90,
	0x15, 0xa8, 0xd5, 0xff, 0x9c, 0xe8, 0xc0, 0x12, 0x1e, 0x93, 0x49, 0xdd, 0xba, 0xaa, 0x38, 0x6d,
	0xa4, 0x7a, 0xcb, 0x40, 0xdf, 0x10, 0xf9, 0x05, 0xa3, 0xd2, 0xc2, 0x4a, 0x63, 0xdc, 0x60, 0xff,
	0xb4, 0x09, 0x96, 0x0a, 0x3f, 0x41, 0xcd, 0x76, 0xca, 0x0a, 0xb2, 0x2a, 0x2b, 0xdc, 0xaa, 0x77,
	0x57, 0x0b, 0x37, 0x6d, 0xa4, 0x7a, 0xeb, 0xb1, 0x93, 0xef, 0xe9, 0xf7, 0xf7, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x9e, 0xc4, 0xb1, 0x7f, 0xbb, 0x02, 0x00, 0x00,
}
